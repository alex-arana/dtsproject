#labels DMI,JSDL
= DMI Discussion Points / Possibilities/ Proposals =

== Intro ==
We are implementing a scalable data transfer service that performs recursive directory copying between different (incompatible) storage/file systems, including, GridFTP, iRODS, SRB, FTP, SFTP, HTTP(S), local FILE, WEBDAV?. 
The service is based on an architecture that deploys data transfer worker agents implemented using Apache Virtual File System (VFS) into a fully scalable worker node pool/cloud. Remote worker nodes are invoked via asynchronous message queues, which are implemented using JMS queues and topics (i.e. asynchronous point-to-point and publish-subscribe message channels). Alternatively, a worker agent can be deployed locally for directly enabling single client applications.  

=== Message Format / Messaging Model ===
To implement this service, we require a message format for describing a data transfer that may consist of multiple data sources and sinks. At present, we have resorted to a composite schema for defining our message formats that combines both JSDL^1^ and DMI^2^ elements with our own proprietary extensions. Ideally, we would like to produce a standards compliant message format (rather than resorting to our proprietary format). 
This wiki identifies some issues/discussion points and proposals.  

^1^JSDL HPC File Staging Profile: http://www.ogf.org/documents/GFD.135.pdf

^2^OGSA Data Movement Interface: http://www.ogf.org/documents/GFD.135.pdf


Two key requirements of the message format are:
  # All messages must be fully self contained and place no assumptions on the underlying transport mechanism so that they are transport agnostic. E.g. the messaging model should be applicable for use with the following delivery methods: 
    * used within the soap body of a doc-literal Web Service invocation
    * simply posted to a RESTfull endpoint
    * posted to a JMS queue/topic
    * email
  # We need to describe multiple data transfers in the same request message. 



===1) Requirement for a Doc-literal/RESTfull (Non-WSRF) DMI rendering ===
At present, DMI appears to be WSRF centric. We require a document-literal type approach that does not require WSRF service factories and instances (accessed via WS-Addressing Endpoint References). We have put together the following proposal at the link below which provides a doc-literal style DMI rendering that wraps multiple data sources and sinks in the same request:  

*Proposal Schema:* http://code.google.com/p/dtsproject/source/browse/trunk/dts-jaxb/src/main/resources/archive/dmi-wrappedMessagesProposals.xsd 

The key difference between this document-centric rendering (above) and the current DMI WSRF-centric approach, is that the doc-centric approach passes a JobID back to the client rather than a WS-Addressing Endpoint Reference (which point to a DMI service Instance previously created from a factory). In addition, since there is no separate service instance, the client must submit the JobID to the service on each subsequent status request/query. 

===2) Need to accommodate multiple transfers in DMI=== 
The current DMI functional spec is used to define a single data transfer between a single source and a single sink. Data aggregates, such as a single directory residing at a single sink can be specified in the [data EPR] (e.g. by appending the '/' char to an EPR to identify a directory). However this appears to account for only a single aggregate/directory. We have a requirement to be able to transfer multiple directories, potentially residing at different locations. 
In order to accommodate multiple transfers in DMI, the client interacts with a DMI factory to create multiple service instances, each responsible for a separate transfer (please correct me/comment on this if i am wrong!). Potentially, this can place a large communication overhead on the client since many interactions are required between the client and service (e.g. consider the case when copying many different files from a number of different sources). 
 
We therefore need to be able to define multiple data transfers within the same request message/packet so that the client can be very thin, i.e. fire a single request and periodically poll for status updates (see http://www.eaipatterns.com/MessagingComponentsIntro.html for the 'atomic' message/packet definition). 

To do this, we have devised the following 'dmi-wrapped' rendering proposal that effectively combines a source and a sink DEPR within a single element which can be defined multiple times in a single request/packet. This is very similar to the {{{<jsdl:DataStaging>}}} elements that can be defined multiple times within a single JSDL document. See the example schema, doc and pseudo code-frag below;

Schema: <br/>
http://code.google.com/p/dtsproject/source/browse/trunk/dts-jaxb/src/main/resources/archive/dmi-wrappedMessagesProposals.xsd 

Full Doc example: <br/>
http://code.google.com/p/dtsproject/source/browse/trunk/dts-jaxb/src/main/resources/archive/dmi-WrappedDataTransferRequest.xml

{{{
   Pseudo schema request:
    ======================
    <dmi-msg:SubmitWrappedDataTransferRequestMessage>
        <dmi-msg:Start/>
        <dmi-msg:WrappedSourceSinkDEPRs>
            <dmi-msg:SourceDEPR></dmi-msg:SourceDEPR>
            <dmi-msg:SinkDEPR></dmi-msg:SinkDEPR>
            <dmi-msg:TransferRequirements/>
        </dmi-msg:WrappedSourceSinkDEPRs>
        <dmi-msg:WrappedSourceSinkDEPRs>
            <dmi-msg:SourceDEPR></dmi-msg:SourceDEPR>
            <dmi-msg:SinkDEPR></dmi-msg:SinkDEPR>
            <dmi-msg:TransferRequirements/>
        </dmi-msg:WrappedSourceSinkDEPRs>
        <dmi-msg:WrappedSourceSinkDEPRs>
            <dmi-msg:SourceDEPR></dmi-msg:SourceDEPR>
            <dmi-msg:SinkDEPR></dmi-msg:SinkDEPR>
            <dmi-msg:TransferRequirements/>
        </dmi-msg:WrappedSourceSinkDEPRs>
        ...
    </dmi-msg:SubmitWrappedDataTransferRequestMessage>

    Pseudo schema response:
    =======================
   <dmi-msg:GetWrappedDataTransferInstanceResponseMessage>
       <dmi-msg:JobID>jobid-adfafq24-59-4-13</dmi-msg:JobID>
   </dmi-msg:GetWrappedDataTransferInstanceResponseMessage>
}}}

At present the proposal above returns a single JobID for the whole 'bulk' transfer (since a bulk transfer can be made up of multiple sub transfers). This implies that any subsequent request that uses this JobID(e.g. a request for state, or a request for the dmi instance attributes document) refers to the state of the whole 'bulk' transfer. For example, the total number of bytes transferred would be calculated across all the sub-transfers. Similarly, if one sub-transfer failed out of ten, then the state of the bulk transfer would be 'failed'. Note, this has similar semantics to defining a [data EPR] that represents a data aggregate residing on the same source, such as a collection of files (see current DMI spec). 

This could certainly be extended further if it is a requirement to query the state of each separate sub-transfer. To do this, the request message (GetDataTransferInstanceRequestType) would have to be extended to incorporate additional user defined sub-transfer tags/ids elements defined for each separate sub-transfer(e.g. mytransferA, mytransferB, mytransferC). In doing this, any subsequent request made by the client could use a combination of the JobID and the sub-transfer tag/id {{{(ie. '<JobID>:<transferTag>')}}} to isolate that specific sub-transfer. The returned state would then represent only that sub-transfer as per the dmi spec.

Note, in this scenario, it would be important that the client assigns the sub-transfer tags/ids while the service assigns the bulk transfer JobID. This is because we do not want to place any significance on the ordering of the sub-transfers in the initial request. 


===3) JSDL CreationOption in DMI ===
Add the the {{{<jsdl:CreationFlag>}}} element, which defines overwrite, dontOverwrite and append enums, to the {{{<dmi:TransferRequirementsType>}}}, e.g. something like the following, but define the CreationFlag within the dmi namespace ?

{{{
        <dmi-msg:TransferRequirements>
            <!--<dmi:StartNotBefore></dmi:StartNotBefore>
            <dmi:EndNoLaterThan>6</dmi:EndNoLaterThan>
            <dmi:StayAliveTime>6</dmi:StayAliveTime>-->
            <dmi:MaxAttempts>2</dmi:MaxAttempts>
            <!-- define CreationFlag in dmi ns ? --> 
            <jsdl:CreationFlag>overwrite</jsdl:CreationFlag>
        </dmi-msg:TransferRequirements>

}}} 



=== 4) Extension points in DMI schema ===
A number of xsd extension points (xsd:any) are required in the current dmi functional spec, e.g in the following DMI elements
  * Data element 
  * list elements here 
  