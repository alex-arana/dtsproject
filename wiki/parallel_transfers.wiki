Thoughts on perfomring parallel transfers

= Parallel transfer considerations =

Each connection to a file system (e.g. SRB) spawns a server process listening on a port in the range you have specified to the file system (ephemeral port range). That server process is connected to by the client and receives commands and data from that client. It is a request/response communication protocol where each side waits for the other to finish before issuing another instruction. If one were to have multiple client threads sharing the same security context (session) and server process, then things would get very confused because the server would be receiving concurrent requests when it is meant to be processing a response for another thread etc. 

In terms of how many authenticated sessions a server can manage, this is usually limited by two factors: 
a) Firstly, the number of high ports available for use by a server process, and 
b) Secondly any protocol specific issues, e.g. for srb, the number of permitted backend DB connections since usually one srbServer process ultimately means 1 DB connection by the MCAT server i.e. SRB does not do connection pooling and reuse.

With these issues in mind, parallelisation using threads should occur by:
  * each thread owning its own thread-local security context/session 
  * NOT by each thead sharing a security context/session

The overhead of having a thread-local security session is minimal. Typically, this would allow a transfer to be parallelized into say ~50 threads (certainly no more than 100?? i guess this depends on your network and the number of available high ports). Special consideration should also be taken when using more than a certain number of threads as the channel/link between two sites/states might be used by other non-DTS users as well. In ARCS, 1000 ports have been opened to be used as ephimeral ports. So if a transfer requires 2 ports, the DTS will have a maximum of 500 threads to use.

=== Parallel Apache Commons VFS Example ===

Create a new {{{DefaultFileSystemManager}}} instance *per thread* (note, if using the VFSUtil helper class, this requires a new call to _createNewFsManager_ for each thread e.g.
{{{
 DefaultFileSystemManager fsManager = new DefaultFileSystemManager();
 fsManager.addProvider("gsiftp", new GridFtpFileProvider());
}}}

=== Protocol native Get/Put rather than byte streaming ===

Commons VFS Grid currently uses a byte streaming approach to transferring files from the source to the destination. We plan to investigate on what advantages/disadvantages we could get if change it to do a native Get/Put approach. This approach would require the files to be staged into the workernode/s and staged out to the target destination. The workernodes will then need to have a big and fast hard drive.